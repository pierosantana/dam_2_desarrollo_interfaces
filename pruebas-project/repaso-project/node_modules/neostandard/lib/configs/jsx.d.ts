export namespace jsx {
    let name: string;
    let ignores: string[];
    namespace languageOptions {
        namespace parserOptions {
            namespace ecmaFeatures {
                let jsx: true;
            }
        }
    }
    namespace plugins {
        let react: import("eslint").ESLint.Plugin;
    }
    namespace settings {
        export namespace react_1 {
            let version: string;
        }
        export { react_1 as react };
        export let linkComponents: string[];
    }
    let rules: {
        'react/jsx-boolean-value': "error";
        'react/jsx-fragments': ["error", string];
        'react/jsx-handler-names': "error";
        'react/jsx-key': ["error", {
            checkFragmentShorthand: boolean;
        }];
        'react/jsx-no-comment-textnodes': "error";
        'react/jsx-no-duplicate-props': "error";
        'react/jsx-no-target-blank': ["error", {
            enforceDynamicLinks: string;
        }];
        'react/jsx-no-undef': ["error", {
            allowGlobals: boolean;
        }];
        'react/jsx-uses-react': "error";
        'react/jsx-uses-vars': "error";
        'react/no-children-prop': "error";
        'react/no-danger-with-children': "error";
        'react/no-deprecated': "error";
        'react/no-direct-mutation-state': "error";
        'react/no-find-dom-node': "error";
        'react/no-is-mounted': "error";
        'react/no-string-refs': ["error", {
            noTemplateLiterals: boolean;
        }];
        'react/no-unescaped-entities': ["error", {
            forbid: string[];
        }];
        'react/no-render-return-value': "error";
        'react/require-render-return': "error";
        'react/self-closing-comp': "error";
    };
}
export namespace jsxStyles {
    let name_1: string;
    export { name_1 as name };
    let ignores_1: string[];
    export { ignores_1 as ignores };
    let rules_1: {
        '@stylistic/jsx-quotes': ["error", string];
        '@stylistic/jsx-closing-bracket-location': ["error", string];
        '@stylistic/jsx-closing-tag-location': "error";
        '@stylistic/jsx-curly-brace-presence': ["error", {
            props: string;
            children: string;
        }];
        '@stylistic/jsx-curly-newline': ["error", {
            multiline: string;
            singleline: string;
        }];
        '@stylistic/jsx-curly-spacing': ["error", {
            attributes: {
                when: string;
                allowMultiline: boolean;
            };
            children: {
                when: string;
                allowMultiline: boolean;
            };
        }];
        '@stylistic/jsx-equals-spacing': ["error", string];
        '@stylistic/jsx-first-prop-new-line': ["error", string];
        '@stylistic/jsx-indent': ["error", number, {
            checkAttributes: boolean;
            indentLogicalExpressions: boolean;
        }];
        '@stylistic/jsx-indent-props': ["error", number];
        '@stylistic/jsx-pascal-case': ["error", {
            allowAllCaps: boolean;
        }];
        '@stylistic/jsx-props-no-multi-spaces': "error";
        '@stylistic/jsx-tag-spacing': ["error", {
            closingSlash: string;
            beforeSelfClosing: string;
            afterOpening: string;
            beforeClosing: string;
        }];
        '@stylistic/jsx-wrap-multilines': ["error", {
            declaration: string;
            assignment: string;
            return: string;
            arrow: string;
            condition: string;
            logical: string;
            prop: string;
        }];
    };
    export { rules_1 as rules };
}
//# sourceMappingURL=jsx.d.ts.map